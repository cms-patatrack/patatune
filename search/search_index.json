{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"patatune","text":"<p>API</p>"},{"location":"api/","title":"patatune Reference","text":"<p>This reference manual details functions, modules, and objects included in patatune, describing what they are and what they do.</p> <p></p> <p>patatune A Python framework for Metaheuristic Multi-Objective Optimization</p> <p>Modules:</p> <ul> <li> <code>metrics</code>           \u2013            <p>Module implementing various multi-objective optimization metrics.</p> </li> <li> <code>mopso</code>           \u2013            <p>Module implementing the Multi-Objective Particle Swarm Optimization (MOPSO) algorithm.</p> </li> <li> <code>objective</code>           \u2013            <p>Module defining various Objective classes for multi-objective optimization in patatune.</p> </li> <li> <code>optimizer</code>           \u2013            <p>Optimizer module for patatune.</p> </li> <li> <code>util</code>           \u2013            <p>Utility functions and classes for Patatune.</p> </li> </ul>"},{"location":"api/#patatune.metrics","title":"metrics","text":"<p>Module implementing various multi-objective optimization metrics.</p> <p>Functions:</p> <ul> <li> <code>generational_distance</code>             \u2013              <p>Calculates the generational distance metric, for any dimension of the pareto front.</p> </li> <li> <code>hypervolume_indicator</code>             \u2013              <p>Calculates the hypervolume indicator metric, for any dimension of the pareto front.</p> </li> <li> <code>inverted_generational_distance</code>             \u2013              <p>Calculates the inverted generational distance metric, for any dimension of the pareto front.</p> </li> <li> <code>nds</code>             \u2013              <p>Returns the non-dominated set from the given front. </p> </li> <li> <code>wfg</code>             \u2013              <p>WFG algorithm for hypervolume calculation</p> </li> </ul>"},{"location":"api/#patatune.metrics.generational_distance","title":"generational_distance","text":"<pre><code>generational_distance(pareto_front, reference_front)\n</code></pre> <p>Calculates the generational distance metric, for any dimension of the pareto front.</p> <p>The generational distance (GD) measures the average distance of points in the obtained Pareto front to the nearest point in the true Pareto front.</p> <p>Parameters:</p> <ul> <li> <code>pareto_front</code>               (<code>ndarray</code>)           \u2013            <p>Represents the pareto front obtained from the optimization algorithm.</p> </li> <li> <code>reference_front</code>               (<code>ndarray</code>)           \u2013            <p>Represents the true pareto front.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The generational distance metric value.</p> </li> </ul>"},{"location":"api/#patatune.metrics.hypervolume_indicator","title":"hypervolume_indicator","text":"<pre><code>hypervolume_indicator(pareto_front, reference_point, reference_hv=1, max_evaluations=10000000)\n</code></pre> <p>Calculates the hypervolume indicator metric, for any dimension of the pareto front.</p> <p>The hypervolume indicator (HV) measures the volume of the objective space dominated by the obtained Pareto front and bounded by a reference point.</p> <p>Parameters:</p> <ul> <li> <code>pareto_front</code>               (<code>ndarray</code>)           \u2013            <p>Represents the pareto front obtained from the optimization algorithm.</p> </li> <li> <code>reference_point</code>               (<code>list or ndarray</code>)           \u2013            <p>A reference point in the objective space, typically chosen to be worse than any point in the pareto front.</p> </li> <li> <code>reference_hv</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>The hypervolume of the reference front for normalization (default: 1).</p> </li> <li> <code>max_evaluations</code>               (<code>int</code>, default:                   <code>10000000</code> )           \u2013            <p>Maximum number of evaluations to perform during hypervolume calculation (default: 10,000,000). Maximum number of evaluations to perform during hypervolume calculation (default: 10,000,000).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The hypervolume indicator metric value normalized by the reference hypervolume.</p> </li> </ul>"},{"location":"api/#patatune.metrics.inverted_generational_distance","title":"inverted_generational_distance","text":"<pre><code>inverted_generational_distance(pareto_front, reference_front)\n</code></pre> <p>Calculates the inverted generational distance metric, for any dimension of the pareto front.</p> <p>The inverted generational distance (IGD) measures the average distance of points in the true Pareto front to the nearest point in the obtained Pareto front.</p> <p>Parameters:</p> <ul> <li> <code>pareto_front</code>               (<code>ndarray</code>)           \u2013            <p>Represents the pareto front obtained from the optimization algorithm.</p> </li> <li> <code>reference_front</code>               (<code>ndarray</code>)           \u2013            <p>Represents the true pareto front.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The inverted generational distance metric value.</p> </li> </ul>"},{"location":"api/#patatune.metrics.nds","title":"nds","text":"<pre><code>nds(front)\n</code></pre> <p>Returns the non-dominated set from the given front. </p> <p>Uses the get_dominated utility function to identify dominated points and filters them out.</p> <p>Parameters:</p> <ul> <li> <code>front</code>               (<code>ndarray</code>)           \u2013            <p>Represents a set of points in the objective space.</p> </li> </ul> <p>Returns:     (np.ndarray): The non-dominated subset of the input front.</p>"},{"location":"api/#patatune.metrics.wfg","title":"wfg","text":"<pre><code>wfg(pareto_front, reference_point, counter, max_evaluations)\n</code></pre> <p>WFG algorithm for hypervolume calculation Reference: While, L., Bradstreet, L., &amp; Barone, L. (2012). A fast way of calculating exact hypervolumes. IEEE Transactions on Evolutionary Computation, 16(1), 86-95. DOI: 10.1109/TEVC.2010.2077298</p> <p>Parameters:</p> <ul> <li> <code>pareto_front</code>               (<code>ndarray</code>)           \u2013            <p>Represents the pareto front obtained from the optimization algorithm.</p> </li> <li> <code>reference_point</code>               (<code>list or ndarray</code>)           \u2013            <p>A reference point in the objective space, typically chosen to be worse than any point in the pareto front.</p> </li> <li> <code>counter</code>               (<code>list</code>)           \u2013            <p>A list containing a single integer to keep track of the number of evaluations performed.</p> </li> <li> <code>max_evaluations</code>               (<code>int</code>)           \u2013            <p>Maximum number of evaluations to perform during hypervolume calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The hypervolume of the pareto front with respect to the reference point.</p> </li> </ul> Note <p>Optionally uses numba's njit for performance optimization.</p>"},{"location":"api/#patatune.mopso","title":"mopso","text":"<p>Module implementing the Multi-Objective Particle Swarm Optimization (MOPSO) algorithm.</p> <p>Modules:</p> <ul> <li> <code>mopso</code>           \u2013            <p>Multi-Objective Particle Swarm Optimization (MOPSO) algorithm implementation.</p> </li> <li> <code>particle</code>           \u2013            <p>Module defining the Particle class for the MOPSO algorithm.</p> </li> </ul>"},{"location":"api/#patatune.mopso.mopso","title":"mopso","text":"<p>Multi-Objective Particle Swarm Optimization (MOPSO) algorithm implementation.</p> <p>Classes:</p> <ul> <li> <code>MOPSO</code>           \u2013            <p>Multi-Objective Particle Swarm Optimization (MOPSO) algorithm.  </p> </li> </ul>"},{"location":"api/#patatune.mopso.mopso.MOPSO","title":"MOPSO","text":"<pre><code>MOPSO(objective, lower_bounds, upper_bounds, param_names=None, num_particles=50, inertia_weight=0.5, cognitive_coefficient=1, social_coefficient=1, initial_particles_position='random', default_point=None, exploring_particles=False, topology='random', max_pareto_length=-1)\n</code></pre> <p>               Bases: <code>Optimizer</code></p> <p>Multi-Objective Particle Swarm Optimization (MOPSO) algorithm.  </p> <p>The MOPSO class implements the MOPSO algorithm for multi-objective optimization problems. It inherits from the base Optimizer class and provides methods for initializing particles, updating their positions and velocities, evaluating their fitness, and maintaining the Pareto front.</p> <p>Attributes:</p> <ul> <li> <code>objective</code>               (<code>Objective</code>)           \u2013            <p>The functions to optimize.</p> </li> <li> <code>lower_bounds</code>               (<code>list</code>)           \u2013            <p>List of lower bounds for each parameter.</p> </li> <li> <code>upper_bounds</code>               (<code>list</code>)           \u2013            <p>List of upper bounds for each parameter. lower and upper bounds are used to check the type of each parameter (int, float, bool)</p> </li> <li> <code>param_names</code>               (<code>list</code>)           \u2013            <p>List of parameter names.</p> </li> <li> <code>num_particles</code>               (<code>int</code>)           \u2013            <p>Number of particles in the swarm.</p> </li> <li> <code>inertia_weight</code>               (<code>float</code>)           \u2013            <p>Inertia weight for velocity update.</p> </li> <li> <code>cognitive_coefficient</code>               (<code>float</code>)           \u2013            <p>Cognitive coefficient for velocity update.</p> </li> <li> <code>social_coefficient</code>               (<code>float</code>)           \u2013            <p>Social coefficient for velocity update.</p> </li> <li> <code>initial_particles_position</code>               (<code>str</code>)           \u2013            <p>Method for initializing particle positions. Options are <code>lower_bounds</code>, <code>upper_bounds</code>, <code>random</code>, <code>gaussian</code>.</p> <ul> <li> <p>if <code>lower_bounds</code>, all particles are initialized at the lower bounds;</p> </li> <li> <p>if <code>upper_bounds</code>, all particles are initialized at the upper bounds;</p> </li> <li> <p>if <code>random</code>, particles are initialized randomly within the bounds;</p> </li> <li> <p>if <code>gaussian</code>, particles are initialized using a truncated Gaussian distribution centered around default_point.</p> </li> </ul> </li> <li> <code>default_point</code>               (<code>list</code>)           \u2013            <p>Default point for <code>gaussian</code> initialization.</p> <ul> <li>if None, the center between lower and upper bounds is used.</li> </ul> </li> <li> <code>exploring_particles</code>               (<code>bool</code>)           \u2013            <p>If True, particles that do not improve for a certain number of iterations are scattered.</p> </li> <li> <code>topology</code>               (<code>str</code>)           \u2013            <p>Topology for social interaction among particles. Options are <code>random</code>, <code>lower_weighted_crowding_distance</code>, <code>higher_weighted_crowding_distance</code>, <code>round_robin</code>.</p> <p>See Particle.get_pareto_leader for more information.</p> </li> <li> <code>max_pareto_length</code>               (<code>int</code>)           \u2013            <p>Maximum length of the Pareto front. If -1, no limit is applied.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>calculate_crowding_distance</code>             \u2013              <p>Calculates the crowding distance for each particle in the Pareto front.</p> </li> <li> <code>check_types</code>             \u2013              <p>Check that lower_bounds and upper_bounds have acceptable types and are consistent.</p> </li> <li> <code>export_state</code>             \u2013              <p>Exports the current state of the MOPSO optimizer to CSV files.</p> </li> <li> <code>get_metric</code>             \u2013              <p>Calculates a specified metric for the current Pareto front.</p> </li> <li> <code>load_state</code>             \u2013              <p>Loads the MOPSO optimizer state from a checkpoint file.</p> </li> <li> <code>optimize</code>             \u2013              <p>Runs the MOPSO optimization process for a specified number of iterations.</p> </li> <li> <code>save_state</code>             \u2013              <p>Saves the current state of the MOPSO optimizer to a checkpoint file.</p> </li> <li> <code>scatter_particle</code>             \u2013              <p>Scatters a particle that has not improved for a certain number of iterations.</p> </li> <li> <code>step</code>             \u2013              <p>Performs a single optimization step in the MOPSO algorithm.</p> </li> <li> <code>update_pareto_front</code>             \u2013              <p>Updates the Pareto front based on the current particles' fitness.</p> </li> </ul>"},{"location":"api/#patatune.mopso.mopso.MOPSO.calculate_crowding_distance","title":"calculate_crowding_distance","text":"<pre><code>calculate_crowding_distance(pareto_front)\n</code></pre> <p>Calculates the crowding distance for each particle in the Pareto front.</p> <p>Parameters:</p> <ul> <li> <code>pareto_front</code>               (<code>list</code>)           \u2013            <p>List of particles representing the current Pareto front.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>point_to_distance</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each particle in the Pareto front to its crowding distance.</p> </li> </ul>"},{"location":"api/#patatune.mopso.mopso.MOPSO.check_types","title":"check_types","text":"<pre><code>check_types()\n</code></pre> <p>Check that lower_bounds and upper_bounds have acceptable types and are consistent.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If any lower or upper bound has an unacceptable type,         or if lower_bounds and upper_bounds have inconsistent types.</p> </li> </ul>"},{"location":"api/#patatune.mopso.mopso.MOPSO.export_state","title":"export_state","text":"<pre><code>export_state()\n</code></pre> <p>Exports the current state of the MOPSO optimizer to CSV files.</p> Uses the FileManager to export <ul> <li>the states of individual particles to 'checkpoint/individual_states.csv'</li> <li>the current Pareto front to 'checkpoint/pareto_front.csv'.</li> </ul>"},{"location":"api/#patatune.mopso.mopso.MOPSO.get_metric","title":"get_metric","text":"<pre><code>get_metric(metric)\n</code></pre> <p>Calculates a specified metric for the current Pareto front.</p> <p>For example:</p> <pre><code>mopso.get_metric(patatune.metrics.generational_distance)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>metric</code>               (<code>function</code>)           \u2013            <p>A metric function that takes two arguments: the Pareto front and the reference front.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>result</code> (              <code>float</code> )          \u2013            <p>The calculated metric value.</p> </li> </ul>"},{"location":"api/#patatune.mopso.mopso.MOPSO.load_state","title":"load_state","text":"<pre><code>load_state()\n</code></pre> <p>Loads the MOPSO optimizer state from a checkpoint file.</p> <p>Uses the FileManager to deserialize and restore the MOPSO object from 'checkpoint/mopso.pkl'.</p>"},{"location":"api/#patatune.mopso.mopso.MOPSO.optimize","title":"optimize","text":"<pre><code>optimize(num_iterations=100, max_iterations_without_improvement=None)\n</code></pre> <p>Runs the MOPSO optimization process for a specified number of iterations.</p> <p>Uses the <code>step</code> method to perform optimization steps and manages the overall optimization loop.</p> <p>Parameters:</p> <ul> <li> <code>num_iterations</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>Total number of iterations to perform.</p> </li> <li> <code>max_iterations_without_improvement</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of iterations a particle can go without improvement before being scattered. If None, no scattering is performed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pareto_front</code> (              <code>list</code> )          \u2013            <p>The final Pareto front after optimization.</p> </li> </ul>"},{"location":"api/#patatune.mopso.mopso.MOPSO.save_state","title":"save_state","text":"<pre><code>save_state()\n</code></pre> <p>Saves the current state of the MOPSO optimizer to a checkpoint file.</p> <p>Uses the FileManager to serialize and save the MOPSO object to 'checkpoint/mopso.pkl'.</p>"},{"location":"api/#patatune.mopso.mopso.MOPSO.scatter_particle","title":"scatter_particle","text":"<pre><code>scatter_particle(particle: Particle)\n</code></pre> <p>Scatters a particle that has not improved for a certain number of iterations.</p> <p>The particle's velocity is adjusted to move it towards less crowded areas of the search space.</p> <p>Parameters:</p> <ul> <li> <code>particle</code>               (<code>Particle</code>)           \u2013            <p>The particle to be scattered.</p> </li> </ul>"},{"location":"api/#patatune.mopso.mopso.MOPSO.step","title":"step","text":"<pre><code>step(max_iterations_without_improvement=None)\n</code></pre> <p>Performs a single optimization step in the MOPSO algorithm.</p> <p>Parameters:</p> <ul> <li> <code>max_iterations_without_improvement</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of iterations a particle can go without improvement before being scattered. If None, no scattering is performed.</p> </li> </ul>"},{"location":"api/#patatune.mopso.mopso.MOPSO.update_pareto_front","title":"update_pareto_front","text":"<pre><code>update_pareto_front()\n</code></pre> <p>Updates the Pareto front based on the current particles' fitness.</p> <p>Returns:</p> <ul> <li> <code>crowding_distances</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each particle in the Pareto front to its crowding distance.</p> </li> </ul>"},{"location":"api/#patatune.mopso.particle","title":"particle","text":"<p>Module defining the Particle class for the MOPSO algorithm.</p> <p>Classes:</p> <ul> <li> <code>Particle</code>           \u2013            <p>Class representing a particle in the MOPSO algorithm.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>boltzmann</code>             \u2013              <p>Computes a probability distribution function (PDF) based on crowding distances.</p> </li> <li> <code>round_robin_topology</code>             \u2013              <p>Selects a leader particle from the Pareto front in a round-robin fashion.</p> </li> <li> <code>weighted_crowding_distance_topology</code>             \u2013              <p>Selects a leader particle from the Pareto front based on crowding distances.</p> </li> </ul>"},{"location":"api/#patatune.mopso.particle.Particle","title":"Particle","text":"<pre><code>Particle(lower_bound, num_objectives, num_particles, id, topology)\n</code></pre> <p>Class representing a particle in the MOPSO algorithm.</p> <p>Attributes:</p> <ul> <li> <code>position</code>               (<code>ndarray</code>)           \u2013            <p>Current position of the particle in the search space.</p> </li> <li> <code>num_objectives</code>               (<code>int</code>)           \u2013            <p>Number of objectives in the optimization problem.</p> </li> <li> <code>num_particles</code>               (<code>int</code>)           \u2013            <p>Total number of particles in the swarm.</p> </li> <li> <code>velocity</code>               (<code>ndarray</code>)           \u2013            <p>Current velocity of the particle.</p> </li> <li> <code>fitness</code>               (<code>ndarray</code>)           \u2013            <p>Current fitness values of the particle for each objective.</p> </li> <li> <code>local_best_fitnesses</code>               (<code>list</code>)           \u2013            <p>List of local best fitness values found by the particle.</p> </li> <li> <code>local_best_positions</code>               (<code>list</code>)           \u2013            <p>List of positions corresponding to the local best fitnesses.</p> </li> <li> <code>iterations_with_no_improvement</code>               (<code>int</code>)           \u2013            <p>Counter for iterations without improvement.</p> </li> <li> <code>id</code>               (<code>int</code>)           \u2013            <p>Unique identifier for the particle.</p> </li> <li> <code>topology</code>               (<code>str</code>)           \u2013            <p>Topology strategy for selecting global best in the swarm.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_pareto_leader</code>             \u2013              <p>Selects a leader particle from the Pareto front based on the specified topology.</p> </li> <li> <code>set_fitness</code>             \u2013              <p>Sets the fitness of the particle and updates its local best if necessary.</p> </li> <li> <code>set_position</code>             \u2013              <p>Sets the position of the particle.</p> </li> <li> <code>set_state</code>             \u2013              <p>Sets the complete state of the particle.</p> </li> <li> <code>update_best</code>             \u2013              <p>Updates the local best fitnesses and positions of the particle based on its current fitness.</p> </li> <li> <code>update_position</code>             \u2013              <p>Updates the position of the particle based on its velocity and the problem boundaries.</p> </li> <li> <code>update_velocity</code>             \u2013              <p>Updates the velocity of the particle based on its local best and the global best.</p> </li> </ul>"},{"location":"api/#patatune.mopso.particle.Particle.get_pareto_leader","title":"get_pareto_leader","text":"<pre><code>get_pareto_leader(pareto_front, crowding_distances)\n</code></pre> <p>Selects a leader particle from the Pareto front based on the specified topology.</p> <p>If the topology is \"random\", a random particle from the Pareto front is selected. If the topology is \"lower_weighted_crowding_distance\", a particle is selected with a probability inversely proportional to its crowding distance calling the weighted_crowding_distance_topology function. If the topology is \"higher_weighted_crowding_distance\", a particle is selected with a probability proportional to its crowding distance calling the weighted_crowding_distance_topology function. If the topology is \"round_robin\", particles are selected in a round-robin fashion based on the particle's ID calling the round_robin_topology function.</p> <p>Parameters:</p> <ul> <li> <code>pareto_front</code>               (<code>list</code>)           \u2013            <p>List of particles representing the current Pareto front.</p> </li> <li> <code>crowding_distances</code>               (<code>dict</code>)           \u2013            <p>Dictionary mapping particles to their crowding distances.</p> </li> </ul>"},{"location":"api/#patatune.mopso.particle.Particle.set_fitness","title":"set_fitness","text":"<pre><code>set_fitness(fitness)\n</code></pre> <p>Sets the fitness of the particle and updates its local best if necessary.</p> <p>Parameters:</p> <ul> <li> <code>fitness</code>               (<code>ndarray</code>)           \u2013            <p>New fitness values for the particle.</p> </li> </ul>"},{"location":"api/#patatune.mopso.particle.Particle.set_position","title":"set_position","text":"<pre><code>set_position(position)\n</code></pre> <p>Sets the position of the particle.</p> <p>Parameters:</p> <ul> <li> <code>position</code>               (<code>ndarray</code>)           \u2013            <p>New position for the particle.</p> </li> </ul>"},{"location":"api/#patatune.mopso.particle.Particle.set_state","title":"set_state","text":"<pre><code>set_state(velocity, position, best_position, fitness, best_fitness)\n</code></pre> <p>Sets the complete state of the particle.</p> <p>Parameters:</p> <ul> <li> <code>velocity</code>               (<code>ndarray</code>)           \u2013            <p>New velocity for the particle.</p> </li> <li> <code>position</code>               (<code>ndarray</code>)           \u2013            <p>New position for the particle.</p> </li> <li> <code>best_position</code>               (<code>list</code>)           \u2013            <p>New list of local best positions for the particle.</p> </li> <li> <code>fitness</code>               (<code>ndarray</code>)           \u2013            <p>New fitness values for the particle.</p> </li> <li> <code>best_fitness</code>               (<code>list</code>)           \u2013            <p>New list of local best fitness values for the particle.</p> </li> </ul>"},{"location":"api/#patatune.mopso.particle.Particle.update_best","title":"update_best","text":"<pre><code>update_best()\n</code></pre> <p>Updates the local best fitnesses and positions of the particle based on its current fitness.</p> <p>Uses the get_dominated utility function to identify non-dominated solutions. Resets the iterations_with_no_improvement counter if there is an improvement.</p>"},{"location":"api/#patatune.mopso.particle.Particle.update_position","title":"update_position","text":"<pre><code>update_position(lower_bound, upper_bound)\n</code></pre> <p>Updates the position of the particle based on its velocity and the problem boundaries.</p> <p>If the variable is of integer type, the new position is rounded. If the variable is of boolean type, the new position is determined by a threshold of 0.5.</p> <p>Parameters:</p> <ul> <li> <code>lower_bound</code>               (<code>ndarray</code>)           \u2013            <p>Lower bounds for each dimension of the search space.</p> </li> <li> <code>upper_bound</code>               (<code>ndarray</code>)           \u2013            <p>Upper bounds for each dimension of the search space.</p> </li> </ul>"},{"location":"api/#patatune.mopso.particle.Particle.update_velocity","title":"update_velocity","text":"<pre><code>update_velocity(pareto_front, crowding_distances, inertia_weight=0.5, cognitive_coefficient=1, social_coefficient=1)\n</code></pre> <p>Updates the velocity of the particle based on its local best and the global best.</p> <p>Parameters:</p> <ul> <li> <code>pareto_front</code>               (<code>list</code>)           \u2013            <p>List of particles representing the current Pareto front.</p> </li> <li> <code>crowding_distances</code>               (<code>dict</code>)           \u2013            <p>Dictionary mapping particles to their crowding distances.</p> </li> <li> <code>inertia_weight</code>               (<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>Weight for the inertia component (default: 0.5).</p> </li> <li> <code>cognitive_coefficient</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Coefficient for the cognitive component (default: 1).</p> </li> <li> <code>social_coefficient</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Coefficient for the social component (default: 1).</p> </li> </ul>"},{"location":"api/#patatune.mopso.particle.boltzmann","title":"boltzmann","text":"<pre><code>boltzmann(crowding_distances, higher)\n</code></pre> <p>Computes a probability distribution function (PDF) based on crowding distances.</p> <p>Parameters:</p> <ul> <li> <code>crowding_distances</code>               (<code>dict</code>)           \u2013            <p>Dictionary mapping particles to their crowding distances.</p> </li> <li> <code>higher</code>               (<code>bool</code>)           \u2013            <p>If True, computes PDF favoring higher crowding distances.             If False, computes PDF favoring lower crowding distances.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A list representing the probability distribution function for selecting particles.</p> </li> </ul>"},{"location":"api/#patatune.mopso.particle.round_robin_topology","title":"round_robin_topology","text":"<pre><code>round_robin_topology(pareto_front, id)\n</code></pre> <p>Selects a leader particle from the Pareto front in a round-robin fashion.</p> <p>The particle is selected based on its ID modulo the size of the Pareto front. If the ID exceeds the size of the Pareto front, it wraps around.</p> <p>Parameters:</p> <ul> <li> <code>pareto_front</code>               (<code>list</code>)           \u2013            <p>List of particles representing the current Pareto front.</p> </li> <li> <code>id</code>               (<code>int</code>)           \u2013            <p>Unique identifier for the particle.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Particle</code>           \u2013            <p>The selected leader particle from the Pareto front.</p> </li> </ul>"},{"location":"api/#patatune.mopso.particle.weighted_crowding_distance_topology","title":"weighted_crowding_distance_topology","text":"<pre><code>weighted_crowding_distance_topology(pareto_front, crowding_distances, higher)\n</code></pre> <p>Selects a leader particle from the Pareto front based on crowding distances.</p> <p>Parameters:</p> <ul> <li> <code>pareto_front</code>               (<code>list</code>)           \u2013            <p>List of particles representing the current Pareto front.</p> </li> <li> <code>crowding_distances</code>               (<code>dict</code>)           \u2013            <p>Dictionary mapping particles to their crowding distances.</p> </li> <li> <code>higher</code>               (<code>bool</code>)           \u2013            <p>If True, selects particles with higher crowding distances with higher probability.             If False, selects particles with lower crowding distances with higher probability.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Particle</code>           \u2013            <p>The selected leader particle from the Pareto front.</p> </li> </ul>"},{"location":"api/#patatune.objective","title":"objective","text":"<p>Module defining various Objective classes for multi-objective optimization in patatune.</p> <p>This module includes the base Objective class and its subclasses.</p> <p>Classes:</p> <ul> <li> <code>AsyncElementWiseObjective</code>           \u2013            <p>Asynchronous element-wise objective class.</p> </li> <li> <code>BatchObjective</code>           \u2013            <p>Batch objective class.</p> </li> <li> <code>ElementWiseObjective</code>           \u2013            <p>Element-wise objective class.</p> </li> <li> <code>Objective</code>           \u2013            <p>Base class for defining objective functions.</p> </li> </ul>"},{"location":"api/#patatune.objective.AsyncElementWiseObjective","title":"AsyncElementWiseObjective","text":"<pre><code>AsyncElementWiseObjective(objective_functions, num_objectives=None, directions=None, objective_names=None, true_pareto=None)\n</code></pre> <p>               Bases: <code>Objective</code></p> <p>Asynchronous element-wise objective class.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Passes each item one by one to each asynchronous objective function and collects the results.</p> </li> </ul>"},{"location":"api/#patatune.objective.AsyncElementWiseObjective.evaluate","title":"evaluate","text":"<pre><code>evaluate(items)\n</code></pre> <p>Passes each item one by one to each asynchronous objective function and collects the results.</p> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>list</code>)           \u2013            <p>List of parameter sets to evaluate of shape (num_particles, num_parameters).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of shape (num_particles, num_objectives) with evaluated objective values.</p> </li> </ul>"},{"location":"api/#patatune.objective.BatchObjective","title":"BatchObjective","text":"<pre><code>BatchObjective(objective_functions, batch_size, num_objectives=None, directions=None, objective_names=None, true_pareto=None)\n</code></pre> <p>               Bases: <code>Objective</code></p> <p>Batch objective class.</p> <p>Inherits from the base Objective class and implements the evaluate method to evaluate each objective function on batches of items asynchronously.</p> <p>Attributes:     batch_size (int): Size of each batch for evaluation.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Passes items in batches to each objective function asynchronously and collects the results.</p> </li> </ul>"},{"location":"api/#patatune.objective.BatchObjective.evaluate","title":"evaluate","text":"<pre><code>evaluate(items)\n</code></pre> <p>Passes items in batches to each objective function asynchronously and collects the results.</p> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>list</code>)           \u2013            <p>List of parameter sets to evaluate of shape (num_particles, num_parameters).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of shape (num_particles, num_objectives) with evaluated objective values.</p> </li> </ul>"},{"location":"api/#patatune.objective.ElementWiseObjective","title":"ElementWiseObjective","text":"<pre><code>ElementWiseObjective(objective_functions, num_objectives=None, directions=None, objective_names=None, true_pareto=None)\n</code></pre> <p>               Bases: <code>Objective</code></p> <p>Element-wise objective class.</p> <p>Inherits from the base Objective class and implements the evaluate method to evaluate each objective function on individual items.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Passes each item one by one to each objective function and collects the results.</p> </li> </ul>"},{"location":"api/#patatune.objective.ElementWiseObjective.evaluate","title":"evaluate","text":"<pre><code>evaluate(items)\n</code></pre> <p>Passes each item one by one to each objective function and collects the results.</p> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>list</code>)           \u2013            <p>List of parameter sets to evaluate of shape (num_particles, num_parameters).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of shape (num_particles, num_objectives) with evaluated objective values.</p> </li> </ul>"},{"location":"api/#patatune.objective.Objective","title":"Objective","text":"<pre><code>Objective(objective_functions, num_objectives=None, directions=None, objective_names=None, true_pareto=None)\n</code></pre> <p>Base class for defining objective functions.</p> <p>The class is used to evaluate multiple objective functions for all particles simultaneously. The classes that inherit from this one should implement the <code>evaluate</code> method.</p> <p>Attributes:</p> <ul> <li> <code>objective_functions</code>               (<code>list</code>)           \u2013            <p>List of objective functions.</p> </li> <li> <code>num_objectives</code>               (<code>int</code>)           \u2013            <p>Number of objectives (optional, default: len(objective_functions)).</p> </li> <li> <code>directions</code>               (<code>list[str]</code>)           \u2013            <p>List indicating whether to 'minimize' or 'maximize' each objective (optional, default: ['minimize', 'minimize', ...]).</p> </li> <li> <code>objective_names</code>               (<code>list</code>)           \u2013            <p>List of names for each objective (optional, default: [\"objective_0\", \"objective_1\", ...]).</p> </li> <li> <code>true_pareto</code>               (<code>array - like</code>)           \u2013            <p>True Pareto front for reference (optional).</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Passes all items to each objective function and collects the results.</p> </li> </ul>"},{"location":"api/#patatune.objective.Objective.evaluate","title":"evaluate","text":"<pre><code>evaluate(items)\n</code></pre> <p>Passes all items to each objective function and collects the results.</p> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>list</code>)           \u2013            <p>List of parameter sets to evaluate of shape (num_particles, num_parameters).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of shape (num_particles, num_objectives) with evaluated objective values.</p> </li> </ul>"},{"location":"api/#patatune.optimizer","title":"optimizer","text":"<p>Optimizer module for patatune.</p> <p>This module contains the base Optimizer class that serves as a foundation for various optimization algorithms implemented in the patatune package.</p> <p>Classes:</p> <ul> <li> <code>Optimizer</code>           \u2013            <p>Base class for optimization algorithms in patatune.</p> </li> </ul>"},{"location":"api/#patatune.optimizer.Optimizer","title":"Optimizer","text":"<pre><code>Optimizer()\n</code></pre> <p>Base class for optimization algorithms in patatune. The class that inherits from this one should implement <code>__init__</code>, <code>step</code>, and <code>optimize</code> methods. Raises a <code>NotImplementedError</code> if any of these methods are not implemented in the subclass.</p> <p>Methods:</p> <ul> <li> <code>optimize</code>             \u2013              <p>Run the optimization process.</p> </li> <li> <code>step</code>             \u2013              <p>Perform a single optimization step.</p> </li> </ul>"},{"location":"api/#patatune.optimizer.Optimizer.optimize","title":"optimize","text":"<pre><code>optimize()\n</code></pre> <p>Run the optimization process. This method should coordinate the optimization steps and handle any necessary setup or teardown for the optimization process.</p>"},{"location":"api/#patatune.optimizer.Optimizer.step","title":"step","text":"<pre><code>step()\n</code></pre> <p>Perform a single optimization step. This method should update the model parameters based on the optimization algorithm.</p>"},{"location":"api/#patatune.util","title":"util","text":"<p>Utility functions and classes for Patatune.</p> <p>This module provides various utility functions and classes used throughout the patatune package, including file management, logging, randomization, and dominance checking.</p> <p>The import of numba and zarr is optional to allow for flexibility in environments where these packages may not be installed.</p> <p>If numba is not installed, a dummy njit decorator is provided that does nothing.</p> <p>If zarr is not installed, a warning is logged and Zarr functionality is disabled.</p> <p>A default logger named \"patatune\" is configured with a custom formatter that adds colors based on log level. (See CustomFormatter for details.)</p> <p>A system-wide exception handler is set up to log uncaught exceptions using the patatune logger. (See handle_exception for details.)</p> <p>Classes:</p> <ul> <li> <code>CustomFormatter</code>           \u2013            <p>Custom logging formatter to add colors based on log level.</p> </li> <li> <code>FileManager</code>           \u2013            <p>File management utility class for saving and loading data in various formats.</p> </li> <li> <code>Randomizer</code>           \u2013            <p>Random number generator utility class.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_dominated</code>             \u2013              <p>Determine which particles are dominated within a population.</p> </li> <li> <code>handle_exception</code>             \u2013              <p>Global exception handler to log uncaught exceptions.</p> </li> </ul>"},{"location":"api/#patatune.util.CustomFormatter","title":"CustomFormatter","text":"<p>               Bases: <code>Formatter</code></p> <p>Custom logging formatter to add colors based on log level.</p> Notes <p>This class customizes the log format by adding color codes for different log levels. DEBUG and INFO messages are grey, WARNING messages are yellow, ERROR messages are red, and CRITICAL messages are bold red.</p> <p>The log is formatted as:</p> <p><code>%(asctime)s - %(name)s - %(levelname)s - %(message)s (%(filename)s:%(lineno)d)</code></p> <p>For example:</p> <p><code>2024-01-01 12:00:00,000 - patatune - WARNING - numba package is not installed. The code will run slower. (util.py:206)</code></p>"},{"location":"api/#patatune.util.FileManager","title":"FileManager","text":"<p>File management utility class for saving and loading data in various formats.</p> <p>This class provides methods to save and load data in CSV, JSON, Zarr, and Pickle formats.</p> <p>Attributes:</p> <ul> <li> <code>saving_enabled</code>               (<code>bool</code>)           \u2013            <p>Global flag to enable/disable saving.</p> </li> <li> <code>saving_csv_enabled</code>               (<code>bool</code>)           \u2013            <p>Flag to enable/disable CSV saving.</p> </li> <li> <code>saving_json_enabled</code>               (<code>bool</code>)           \u2013            <p>Flag to enable/disable JSON saving.</p> </li> <li> <code>saving_zarr_enabled</code>               (<code>bool</code>)           \u2013            <p>Flag to enable/disable Zarr saving.</p> </li> <li> <code>saving_pickle_enabled</code>               (<code>bool</code>)           \u2013            <p>Flag to enable/disable Pickle saving.</p> </li> <li> <code>loading_enabled</code>               (<code>bool</code>)           \u2013            <p>Global flag to enable/disable loading.</p> </li> <li> <code>headers_enabled</code>               (<code>bool</code>)           \u2013            <p>Flag to enable/disable headers when saving/loading CSV files.</p> </li> <li> <code>working_dir</code>               (<code>str</code>)           \u2013            <p>Directory where files will be saved/loaded from.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>load_csv</code>             \u2013              <p>Load data from a CSV file.</p> </li> <li> <code>load_json</code>             \u2013              <p>Load a dictionary from a JSON file.</p> </li> <li> <code>load_pickle</code>             \u2013              <p>Load an object from a Pickle file.</p> </li> <li> <code>save_csv</code>             \u2013              <p>Save a list of lists or 2D array to a CSV file.</p> </li> <li> <code>save_json</code>             \u2013              <p>Save a dictionary to a JSON file.</p> </li> <li> <code>save_pickle</code>             \u2013              <p>Save an object to a Pickle file.</p> </li> <li> <code>save_zarr</code>             \u2013              <p>Save a dictionary of arrays to a Zarr file.</p> </li> </ul>"},{"location":"api/#patatune.util.FileManager.load_csv","title":"load_csv  <code>classmethod</code>","text":"<pre><code>load_csv(filename)\n</code></pre> <p>Load data from a CSV file.</p> <p>The method loads data from a CSV file in the <code>working_dir</code> path. If <code>headers_enabled</code> is True, it assumes the first row contains headers.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Name of the input CSV file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>A tuple containing the data as a NumPy array of floats and the headers (if any) as a NumPy array of strings.</p> </li> </ul>"},{"location":"api/#patatune.util.FileManager.load_json","title":"load_json  <code>classmethod</code>","text":"<pre><code>load_json(filename)\n</code></pre> <p>Load a dictionary from a JSON file.</p> <p>The method loads a dictionary from a JSON file in the <code>working_dir</code> path.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Name of the input JSON file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The loaded dictionary.</p> </li> </ul>"},{"location":"api/#patatune.util.FileManager.load_pickle","title":"load_pickle  <code>classmethod</code>","text":"<pre><code>load_pickle(filename)\n</code></pre> <p>Load an object from a Pickle file.</p> <p>The method loads an object from a Pickle file in the <code>working_dir</code> path.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Name of the input Pickle file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>any</code>           \u2013            <p>The loaded object.</p> </li> </ul>"},{"location":"api/#patatune.util.FileManager.save_csv","title":"save_csv  <code>classmethod</code>","text":"<pre><code>save_csv(csv_list, filename='file.csv', headers=None)\n</code></pre> <p>Save a list of lists or 2D array to a CSV file.</p> <p>The method saves the data to a CSV file in the <code>working_dir</code> path. The CSV file is comma-separated and the data is written as floats with 18 decimal places and dot as decimal separator. The method creates the necessary directories if they do not exist. If headers are provided and <code>headers_enabled</code> is True, they will be written as the first row.</p> <p>Parameters:</p> <ul> <li> <code>csv_list</code>               (<code>list[list] | ndarray</code>)           \u2013            <p>Data to be saved.</p> </li> <li> <code>filename</code>               (<code>str</code>, default:                   <code>'file.csv'</code> )           \u2013            <p>Name of the output CSV file.</p> </li> <li> <code>headers</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>Column headers for the CSV file.</p> </li> </ul>"},{"location":"api/#patatune.util.FileManager.save_json","title":"save_json  <code>classmethod</code>","text":"<pre><code>save_json(dictionary, filename)\n</code></pre> <p>Save a dictionary to a JSON file.</p> <p>The method saves a dictionary to a JSON file in the <code>working_dir</code> path. It creates the necessary directories if they do not exist.</p> <p>Parameters:</p> <ul> <li> <code>dictionary</code>               (<code>dict</code>)           \u2013            <p>Dictionary to be saved.</p> </li> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Name of the output JSON file.</p> </li> </ul>"},{"location":"api/#patatune.util.FileManager.save_pickle","title":"save_pickle  <code>classmethod</code>","text":"<pre><code>save_pickle(obj, filename)\n</code></pre> <p>Save an object to a Pickle file.</p> <p>The method saves an object to a Pickle file in the <code>working_dir</code> path. It creates the necessary directories if they do not exist.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>any</code>)           \u2013            <p>The object to be saved.</p> </li> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Name of the output Pickle file.</p> </li> </ul>"},{"location":"api/#patatune.util.FileManager.save_zarr","title":"save_zarr  <code>classmethod</code>","text":"<pre><code>save_zarr(obj, filename, **kwargs)\n</code></pre> <p>Save a dictionary of arrays to a Zarr file.</p> <p>The method saves a dictionary of arrays to a Zarr file in the <code>working_dir</code> path. It creates the necessary directories if they do not exist. The keys of the dictionary are used as group names in the Zarr file. If a key is an integer, it is prefixed with \"iteration_\" to form the group name. Additional attributes can be added to the root group via <code>kwargs</code>.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>dict</code>)           \u2013            <p>The dictionary of arrays to be saved.</p> </li> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Name of the output Zarr file.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional attributes to be saved in the root group as key-value pairs where the key is the attribute name and the value is the attribute value.</p> </li> </ul>"},{"location":"api/#patatune.util.Randomizer","title":"Randomizer","text":"<p>Random number generator utility class.</p> <p>Implements a class-level random number generator using NumPy's default_rng. This class provides a shared random number generator that can be used throughout the package. Can be accessed via <code>Randomizer.rng</code>.</p> <p>For example, to set a seed:</p> <pre><code>Randomizer.rng = np.random.default_rng(seed=42)\n</code></pre>"},{"location":"api/#patatune.util.get_dominated","title":"get_dominated","text":"<pre><code>get_dominated(particles, pareto_length)\n</code></pre> <p>Determine which particles are dominated within a population.</p> <p>Parameters:</p> <ul> <li> <code>particles</code>               (<code>ndarray</code>)           \u2013            <p>2-D array of objective values for each particle (shape: [n_particles, n_objectives]).</p> </li> <li> <code>pareto_length</code>               (<code>int</code>)           \u2013            <p>Number of particles considered part of the current Pareto set (these are skipped in comparisons).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Boolean array of length <code>len(particles)</code> where True means the particle is dominated by at least one other particle.</p> </li> </ul> Notes <p>The function is decorated with a (possible) <code>njit</code> to allow optional numba acceleration.</p>"},{"location":"api/#patatune.util.handle_exception","title":"handle_exception","text":"<pre><code>handle_exception(exc_type, exc_value, exc_traceback)\n</code></pre> <p>Global exception handler to log uncaught exceptions.</p> <p>The function logs uncaught exceptions using the default patatune logger.</p> <p>Parameters:</p> <ul> <li> <code>exc_type</code>               (<code>type</code>)           \u2013            <p>The exception type.</p> </li> <li> <code>exc_value</code>               (<code>Exception</code>)           \u2013            <p>The exception instance.</p> </li> <li> <code>exc_traceback</code>               (<code>traceback</code>)           \u2013            <p>The traceback object.</p> </li> </ul>"}]}